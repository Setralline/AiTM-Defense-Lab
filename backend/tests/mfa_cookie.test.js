const request = require('supertest');
const app = require('../server'); 
const pool = require('../config/db');
const { createInitialAdmin } = require('../config/initDb');
const speakeasy = require('speakeasy');

describe('Level 1 MFA Session Fix (Cookie Mode)', () => {
  let adminToken;
  let mfaSecret;
  const adminEmail = 'admin@lab.com';
  // Note: Password will be generated by initDb, but for testing we need a known state.
  // Since createInitialAdmin generates a random password, we will manually reset it 
  // for this test to ensure we can login.
  const knownPassword = 'TestPassword1!'; 

  // 1. SETUP: Initialize DB and create a predictable Admin
  beforeAll(async () => {
    // Initialize standard DB
    await createInitialAdmin();
    
    // Manually update admin password to something we know for testing
    const bcrypt = require('bcryptjs');
    const salt = await bcrypt.genSalt(10);
    const hashed = await bcrypt.hash(knownPassword, salt);
    await pool.query('UPDATE users SET password = $1 WHERE email = $2', [hashed, adminEmail]);
  });

  // 2. TEARDOWN: Close DB connection
  afterAll(async () => {
    await pool.end();
  });

  it('Step 1: Authenticate to get initial token', async () => {
    const res = await request(app)
      .post('/auth/admin/login')
      .send({ email: adminEmail, password: knownPassword });

    expect(res.statusCode).toEqual(200);
    adminToken = res.body.token;
  });

  it('Step 2: Enable MFA for the account', async () => {
    const res = await request(app)
      .post('/auth/mfa/enable')
      .set('Authorization', `Bearer ${adminToken}`)
      .send({ email: adminEmail });

    expect(res.statusCode).toEqual(200);
    mfaSecret = res.body.secret;
  });

  it('Step 3: Verify MFA with isCookieAuth: true (THE FIX)', async () => {
    // Generate a valid TOTP code
    const code = speakeasy.totp({
      secret: mfaSecret,
      encoding: 'base32'
    });

    // Perform the verification request mimicking Level 1
    const res = await request(app)
      .post('/auth/mfa/verify')
      // Note: We don't necessarily need the Bearer token here if the endpoint 
      // relies purely on email+code, but providing it mimics auth flow context often.
      // However, the critical part is the body payload.
      .send({ 
        email: adminEmail, 
        code: code,
        isCookieAuth: true, // <--- THIS IS THE FLAG WE ADDED
        rememberMe: false
      });

    expect(res.statusCode).toEqual(200);

    // CRITICAL ASSERTION 1: Cookie must be set
    // This proves the backend is treating it as a legacy session
    expect(res.headers['set-cookie']).toBeDefined();
    
    // CRITICAL ASSERTION 2: Token must NOT be in the body
    // This proves we aren't exposing the JWT to LocalStorage (XSS protection)
    expect(res.body.token).toBeUndefined();
    
    // Ensure user data is still returned
    expect(res.body.user).toBeDefined();
    expect(res.body.user.email).toBe(adminEmail);
  });
});